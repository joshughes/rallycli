#!/usr/bin/env ruby

require 'ostruct'
require 'rubygems'
require 'commander/import'
require 'redcarpet'
require 'rouge'
require 'rouge/plugins/redcarpet'
require 'terminal-table'
require_relative '../lib/rally/cli'
require_relative '../lib/helpers/command_line'

class HTML < Redcarpet::Render::HTML
  def block_code(code, language)
    lexer = Rouge::Lexer.find_fancy(language, code) || Rouge::Lexers::PlainText

    # XXX HACK: Redcarpet strips hard tabs out of code blocks,
    # so we assume you're not using leading spaces that aren't tabs,
    # and just replace them here.
    if lexer.tag == 'make'
      code.gsub! /^    /, "\t"
    end

    formatter = rouge_formatter(lexer)
    formatter.format(lexer.lex(code))
  end

  # override this method for custom formatting behavior
  def rouge_formatter(lexer)
    Rouge::Formatters::HTML.new(:inline_theme =>  Rouge::Themes::Github.new, :css_class => "highlight #{lexer.tag}")
  end

end


program :version, '0.0.1'
program :description, 'Command line interface for Rally'

@rally_cli = Rally::Cli.new
@command_line_helper = Rally::CommandLine
#@task = @rally_cli.current_task
@high_line = HighLine.new

command :current_task do |c|
  c.syntax = 'rally_cli current_task [options]'
  c.summary = ''
  c.description = ''
  c.example 'description', 'command example'
  c.option '--some-switch', 'Some switch that does something'
  c.action do |args, options|
    say("#{@rally_cli.current_task.formattedID}: #{@rally_cli.current_task.name}")
  end
end

command :current_story do |c|
  c.syntax = 'rally_cli current_story [options]'
  c.summary = ''
  c.description = ''
  c.example 'description', 'command example'
  c.option '--some-switch', 'Some switch that does something'
  c.action do |args, options|
    say("#{@rally_cli.current_story.formattedID}: #{@rally_cli.current_story.name}")
  end
end

command :show_stories do |c|
  c.syntax = 'rally_cli show_stories [options]'
  c.summary = ''
  c.description = ''
  c.example 'description', 'command example'
  @rally_cli.config[:show][:story][:options].each do | show_option, show_option_filter |
    c.option "--#{show_option}", "Only show stories where #{show_option_filter}"
  end
  c.action do |args, options|
    story_filter = []
    display = @rally_cli.config[:show][:story][:display]
    options.__hash__.keys.each do | option |
      story_filter << @rally_cli.config[:show][:story][:options][option.to_sym]
    end

    stories = @rally_cli.stories([:all_iterations],story_filter)
    table = Terminal::Table.new do |t|
      stories.each do | story |
        row = []
        display.each do | attribute |
          row << story.rally_object.send(attribute.to_s.camelize.sub('Id','ID'))
        end
        t.add_row row
        t.add_separator
        t.headings = display
      end
    end
    puts table
  end
end

command :work_progress do |c|
  c.syntax = 'rally_cli work_progress [options]'
  c.description = 'Display the hours spent on the current_task'
  c.example 'description', 'command example'
  c.option '--some-switch', 'Some switch that does something'
  c.action do |args, options|
    say("You have spent #{@task.progress} hours working on task #{@task.formattedID}")
  end
end

command :set_task do |c|
  c.syntax = 'rally_cli set_task [options]'
  c.description = 'Display tasks for the user to select a task to work on'
  c.example 'description', 'command example'
  c.option '--some-switch', 'Some switch that does something'
  c.action do |args, options|
    menu = {
      options:       @rally_cli.tasks(options),
      prompt:        "Please choose the task you wish to work on.",
      option_text:   proc { |option| "#{option.formattedID}: #{option.description}"},
      option_action: proc { |option| @rally_cli.current_task = option; exit }
    }
    menu_select(menu)
  end
end

command :set_story do |c|
  c.syntax = 'rally_cli set_story [options]'
  c.description = 'Display stories for the user to select a story to work on'
  c.example 'description', 'command example'
  c.option '--some-switch', 'Some switch that does something'
  c.action do |args, options|
    menu = {
      options:       @rally_cli.stories(options),
      prompt:        "Please choose the story you wish to work on.",
      option_text:   proc { |option| "#{option.formattedID}: #{option.description}"},
      option_action: proc { |option| @rally_cli.current_story = option; exit}
    }
    menu_select(menu)
  end
end

command :create_story do |c|
  c.syntax = 'rally_cli create_story'
  c.description = 'Create a new story for your project'
  c.example 'description', 'command example'
  @command_line_helper.set_command_options('Story', c, @rally_cli.config)
  c.action do |args, options|
    create_object('Story', options)
  end
end

command :create_task do |c|
  c.syntax = 'rally_cli create_story'
  c.description = 'Create a new task for a story'
  c.example 'description', 'command example'
  @command_line_helper.set_command_options('Task', c, @rally_cli.config)
  c.action do |args, options|
    create_object('Task', options)
  end
end

command :edit_task do |c|
  c.syntax = 'rally_cli edit_task [options]'
  c.description = 'Edit a feild of the current task'
  c.example 'description', 'command example'
  c.option '--some-switch', 'Some switch that does something'
  c.action do |args, options|
    edit_object(@rally_cli.current_task, args[0])
  end
end

command :edit_story do |c|
  c.syntax = 'rally_cli edit_story [options]'
  c.summary = ''
  c.description = ''
  c.example 'description', 'command example'
  c.option '--some-switch', 'Some switch that does something'
  c.action do |args, options|
    edit_object(@rally_cli.current_story, args[0])
  end
end


private


def create_object(clazz, options)
  passed_options = options.__hash__.keys.map { |x| x.to_s }
  new_object = OpenStruct.new(options.__hash__)
  new_object.clazz = clazz
  required_fields = @rally_cli.config[:creation][clazz.downcase.to_sym][:required]
  binding.pry
  required_fields = required_fields - passed_options
  required_fields.each do |field|
    new_object = edit_object(new_object, field, options)
  end
  clazz = Object.const_get("Rally::#{new_object.clazz.capitalize}")
  new_object = clazz.create(new_object, @rally_cli.current_user, @rally_cli)
  say("A new rally #{clazz.rally_type} #{new_object.formattedID} was created!")
end


def edit_object(object, edit_field, options=nil)
  if object.instance_of? OpenStruct
    clazz = Object.const_get("Rally::#{object.clazz.capitalize}")
    clazz.rally_methods(@rally_cli.config)
  else
    clazz = object.class
  end
  if(clazz::EDITABLE_TEXT_FIELDS.include?(edit_field))
    render_options = {
      filter_html:     true,
      hard_wrap:       true,
      link_attributes: { rel: 'nofollow' }
    }
    renderer = HTML.new(render_options)
    extensions = {
      autolink:           true,
      fenced_code_blocks: true,
      lax_spacing:        true,
      no_intra_emphasis:  true,
      strikethrough:      true,
      superscript:        true
    }
    markdown = Redcarpet::Markdown.new(renderer, extensions)
    current_value = object.send(edit_field)
    user_input = ask_editor(current_value || "Please create a #{edit_field}")
    user_input = markdown.render(user_input) if clazz::MARKDOWN_TEXT_FIELDS.include?(edit_field)
    object.send(edit_field+"=", user_input)
  elsif(clazz::EDITABLE_BOOLEAN_FIELDS.include?(edit_field))
    object.send(edit_field+"=",@high_line.agree("Is #{object.formattedID} #{edit_field}?"))
  elsif(clazz::EDITABLE_OBJECT_RELATIONS.include?(edit_field))
    select_relation(object, edit_field, options)
  elsif(clazz::EDITABLE_SELECT_FIELDS.has_key?(edit_field.to_s))
    select_fields(object, edit_field, clazz::EDITABLE_SELECT_FIELDS[edit_field.to_s], options)
  else
    say("#{edit_field.capitalize} is not editable for #{object.class} #{object.formattedID}")
  end
  return object
end

def select_fields(object, edit_field, select_options, options=nil)
  menu={
    options: select_options,
    prompt:  "Please select the value to set for #{edit_field}",
    option_text:   proc { |option| "#{option}"},
    option_action: proc { |option| object.send("#{edit_field}=", option) }
  }
  menu_select(menu)
end

def select_relation(object, relation_field, options=nil)
  menu ={
    options:       @rally_cli.send("#{relation_field.pluralize}",options),
    prompt:        "Please choose the new #{relation_field} for #{object.class} #{object.formattedID}",
    option_text:   proc { |option| "#{option.formattedID}: #{option.name}"},
    option_action: proc { |option| object.send("#{relation_field}=",option.objectID)}
  }
  menu_select(menu)
end

def menu_select(menu_hash)
  groups = menu_hash[:options].each_slice(10).to_a
  groups.cycle do |options|
    system("clear")
    @high_line.choose do | menu |
      menu.prompt = menu_hash[:prompt]
      menu.prompt += "\n next: for next 10 results" if groups.length > 1
      menu.prompt += "\n quit: to exit"
      menu.shell  = false

      options.each do |option|
        menu.choice(menu_hash[:option_text].call(option)) do
          menu_hash[:option_action].call(option)
          return nil
        end
      end
      menu.hidden(:next, "Next page") { next }
      menu.hidden(:quit, "Exit program.") { exit }
    end
  end
end
